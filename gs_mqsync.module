<?php

static $connection;

/**
 * Utility functions
 */

/**
 * Find a node representing a chapter, with a URL that matches the update origin
 */
function _gs_mqsync_find_chapter($url) {
  // normalize
  $url = str_ireplace('http://', '', $url);

  $query = new EntityFieldQuery();
  $query->entityCondition('entity_type', 'node');
  $query->entityCondition('bundle', 'go_chapter');
  $query->fieldCondition('field_member_url', 'url', '%'.$url, 'LIKE');
  $result = $query->execute();

  if( isset($result['node']) ) {
    $list = array_keys($result['node']);
    $chapter = node_load(reset($list));
    return $chapter;
  } else {
    watchdog('gs_mqsync', "No chapter was found with member URL like {$url}");
  }

  return null;
}

/**
 * semaphore to prevent loops while receiving a sync
 * - call with argument to set
 * - call with no argument to read
 */
function _gs_mqsync_receiving($set = null) {
  static $gs_mqsync_receiving_updates;
  if( !is_null($set) ) {
    $gs_mqsync_receiving_updates = $set;
  }
  return $gs_mqsync_receiving_updates;
}

/**
 * Substitute role IDs with machine names, and only send the named roles
 */
function _gs_mqsync_fix_roles($roles) {
  static $rolemap;
  if( !isset($rolemap) ) {
    $rolemap = db_query("SELECT rid, machine_name FROM role")->fetchAllKeyed();
  }
  $new_roles = array();
  foreach(array_keys($roles) AS $rid) {
    $machine_name = $rolemap[$rid];
    if( _g3core_role_category($machine_name) == 'named' ) {
      $new_roles[] = $machine_name;
    }
  }
  return $new_roles;
}

/**
 * Substitute term machine names for terms
 */
function _gs_mqsync_fix_taxonomy($tax) {
  // for single values
  if( isset($tax['tid']) ) {
    return db_query("SELECT machine_name FROM taxonomy_term_data WHERE tid = :tid",
      array(':tid'=>$tax['tid']))->fetchField();
  }
  // multi-value term reference fields
  if( isset($tax[0]['tid']) ) {
    $r = array();
    foreach($tax AS $t) {
      $r[] = _gs_mqsync_fix_taxonomy($t);
    }
    return $r;
  }
  // return whatever this was unchanged
  return $tax;
}

/** 
 * Convert domain name to queue name
 */
function _gs_mqsync_convert_domain_to_queue_name($domain) {
  // strip off any prefix
  $queue_name = str_replace('http://', '', $domain);
  // replace dots with underscore
  $queue_name = str_replace('.', '_', $queue_name);
  // trim just in case
  $queue_name = trim($queue_name);
  return $queue_name;
}


function gs_mqsync_menu() {

  // admin interface
  $items['admin/config/groupanizer/sync'] = array(
    'title' => 'Sync settings',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('gs_mqsync_settings_form'),
    'access arguments' => array('only user 1'),
    'file' => 'gs_mqsync.admin.inc',
  );

  // TEMPORARY
  $items['univrec'] = array(
    'title' => "Receive updated from universe",
    'page callback' => 'gs_mqsync_receive_updates',
    'access arguments' => array('bypass node access'),
    'type' => MENU_CALLBACK,
  );

  return $items;
}


/**
 * hook_cron
 * @purpose processes pending messages in the queue
 */
function gs_mqsync_cron() {
  gs_mqsync_process_queue();
}

/**
 * Main send method
 */
function gs_mqsync_send($queue, $operation, $package) {

  global $connection;

  if( !isset($connection) ) {
    $connection = RabbitMQConnection::get();
  }
  $channel = $connection->channel();
  $channel->queue_declare('universe_user', false, false, false, false);
  $msg = new  AMQPMessage(serialize(array(
    'operation' => $operation,
    'domain' => g3core_get_domain(),
    'data' => $package,
  )));
  $channel->basic_publish($msg, '', 'universe_user');
  
}

/**
 * define which fields we care about, for sending to universe or
 * for determining if a record has changed materially
 */
function gs_mqsync_person_fields() {
  static $fields;
  if( !isset($fields) ) {
    $fields = array(
      array( 'name'=>'uuid', 'type'=>'scalar'),
      array( 'name'=>'name', 'type'=>'scalar'),
      array( 'name'=>'pass', 'type'=>'scalar'),
      array( 'name'=>'mail', 'type'=>'scalar'),
      array( 'name'=>'picture', 'type'=>'scalar'),
      array( 'name'=>'roles', 'type'=>'roles'),
      array( 'name'=>'field_first_name', 'type'=>'textfield'),
      array( 'name'=>'field_last_name', 'type'=>'textfield'),
      array( 'name'=>'field_member_id', 'type'=>'textfield'),
      array( 'name'=>'field_birthday', 'type'=>'datefield'),
      array( 'name'=>'field_address', 'type'=>'location'),
      array( 'name'=>'field_home_phone', 'type'=>'textfield'),
      array( 'name'=>'field_work_phone', 'type'=>'textfield'),
      array( 'name'=>'field_mobile_phone', 'type'=>'textfield'),
      array( 'name'=>'field_member_since', 'type'=>'datefield'),
      array( 'name'=>'field_dues_paid_until', 'type'=>'datefield'),
      array( 'name'=>'field_voice_part', 'type'=>'taxonomy'),
    );
    drupal_alter('mqsync_fields', $fields);
  }
  return $fields;
}

/**
 * clean up the person object for sending
 */
function gs_mqsync_send_person($queue, $operation, $account) {

  // just the fields we care about, and grab the best language
  $lang = isset($account->language) ? $account->language : LANGUAGE_NONE;
  $package = new StdClass();

  foreach( gs_mqsync_person_fields() AS $spec ) {

    $field_type = $spec['type'];
    $field = $spec['name'];

    switch( $field_type ) {
      case 'scalar':
        $package->$field = $account->$field;
        break;

      case 'roles':
        $package->$field = _gs_mqsync_fix_roles($account->$field);
        break;

      case 'textfield':
        if( isset($account->{$field}[$lang][0]) ) {
          $package->$field = $account->{$field}[$lang][0]['value'];
        } else if( isset($account->{$field}[LANGUAGE_NONE][0]) ) {
          $package->$field = $account->{$field}[LANGUAGE_NONE][0]['value'];
        }
        break;

      case 'datefield':
        if( isset($account->{$field}[$lang][0]) ) {
          $package->$field = $account->{$field}[$lang][0]['value'];
        } else if( isset($account->{$field}[LANGUAGE_NONE][0]) ) {
          $package->$field = $account->{$field}[LANGUAGE_NONE][0]['value'];
        }
        break;

      case 'location':
        if( isset($account->{$field}[LANGUAGE_NONE][0]) ) {
          $package->$field = $account->{$field}[LANGUAGE_NONE][0];
          // get rid of cruft
          unset($package->{$field}['location_settings']);
        }
        break;

      case 'taxonomy':
        // pass the whole array
        if( isset($account->{$field}[$lang] ) ) {
          $package->$field = $account->{$field}[$lang];
        } else if( isset($account->{$field}[LANGUAGE_NONE] ) ) {
          $package->$field = $account->{$field}[LANGUAGE_NONE];
        }
        // substitute machine names
        $package->$field = _gs_mqsync_fix_taxonomy($package->$field);
        break;

      default:
        watchdog('gs_mqsync', "Unknown field type @type received - doing nothing.", array('@type'=>$field_type));
        break;
    }
  }

  gs_mqsync_send($queue, $operation, $package);
}

/**
 * hook_user_insert
 */
function gs_mqsync_user_insert(&$edit, $account, $category) {
  if( !variable_get('gs_mqsync_sync_send', TRUE) || _gs_mqsync_receiving() ) return;
  gs_mqsync_send_person('user', 'create', $account);
}

/**
 * hook_user_update
 */
function gs_mqsync_user_update(&$edit, $account, $category) {
  if( !variable_get('gs_mqsync_sync_send', TRUE) || _gs_mqsync_receiving() ) return;

// for now just send it all the time
gs_mqsync_send_person('user', 'update', $account);
return;

// later we'll skip sending if nothing changed
  foreach( gs_mqsync_person_fields() AS $field ) {
    if( !isset($account->$field) ) continue;
    if( $account->$field != $account->original->$field ) {
      gs_mqsync_send_person('user', 'update', $account);
      return;
    }
  }
}

/**
 * hook_user_delete
 */
function gs_mqsync_user_delete($account) {
  if( !variable_get('gs_mqsync_sync_send', TRUE) || _gs_mqsync_receiving() ) return;
  gs_mqsync_send('user', 'delete', $account->uuid);
}





/**
 * Manually grab any pending updates in the queue
 */
function gs_mqsync_receive_updates() {
  $result = gs_mqsync_process_queue();
  return 
    "Created {$result['created']} records<br>
    Updated {$result['updated']} records<br>
    Deleted {$result['deleted']} records<br>";

}

/**
 * Receive any pending messages and make the corresponding updates
 */

function gs_mqsync_process_queue() {

  // don't do this if we're not set up to receive
  if( !variable_get('gs_mqsync_sync_receive', TRUE) ) return;
  // set the flag that will prevent these from going back out and making a loop
  _gs_mqsync_receiving(TRUE);


  global $connection;
  if( !isset($connection) ) {
    $connection = RabbitMQConnection::get();
  }
  $channel = $connection->channel();

  // get our queue
  $queue_name = _gs_mqsync_convert_domain_to_queue_name(g3core_get_domain());
  $channel->queue_declare($queue_name, false, false, false, false);

  $created_count = $updated_count = $deleted_count = 0;
  while( $msg = $channel->basic_get($queue_name, true) ) {
    $package = unserialize($msg->body);

    switch($package['operation']) {
      case 'person_update':
        $created = gs_mqsync_process_person_update($package['data']);
        if( $created ) {
          $created_count++;
        } else {
          $updated_count++;
        }
        break;

      case 'person_delete':
        $deleted = gu_mqsync_process_person_delete($package['data']);
        if( $deleted ) {
          $deleted_count++;
        }
        break;

      default:
        watchdog('gs_mqsync', "Unknown operation @op received - doing nothing.", array('@op'=>$data['operation']));
        break;
    }


  }

  // shut down the channel now that we're done with it
  $channel->close();
  $connection->close();
  unset($connection);
  
  return array(
    'created' => $created_count,
    'updated' => $updated_count,
    'deleted' => $deleted_count,
  );
}

/**
 * Process an incoming person record from Universe
 * @return TRUE if we created a new record, FALSE for an update
 */
function gs_mqsync_process_person_update($update_package) {

  try {

    $membership = $update_package['membership'];
    $person = $update_package['person'];

    // first let's see if we've already got a record for this person, by UUID
    $uuid = $person->uuid;
    $query = new EntityFieldQuery();
    $query->entityCondition('entity_type', 'user');
    $query->propertyCondition('uuid', $uuid);
    $result = $query->execute();

    if( isset($result['user']) ) {
      $ids = array_keys($result['user']);
      $list = entity_load('user', $ids);
      $user = reset($list);
      $created = FALSE;
    } else {
      $user = entity_create('user', array('type'=>'user'));
      $user->uuid = $uuid;
      $created = TRUE;
      // some fields that should only be set on creation
      $user->status = 1;
      $user->name = strtolower("{$person->first_name}.{$person->last_name}");
      // email handling
      // TODO: detect possible collisions, and maybe merge the records or flag them to merge
      foreach($person->emails AS $e) {
        if( $e->is_primary ) {
          $user->mail = $e->email;
        }
      }
      // give this account the default roles
      $user->roles = variable_get('gs_mqsync_default_roles', array(4190371=>4190371));
    }

    // now update remaining fields and save the user object
    $uw = entity_metadata_wrapper('user', $user);
    $uw->field_first_name = $person->first_name;
    $uw->field_last_name = $person->last_name;

    // field_address
    $a = $person->field_address->und[0];
    $user->field_address[LANGUAGE_NONE][0] = array(
      'is_primary' => TRUE,
      'street' => $a->street,
      'city' => $a->city,
      'province' => $a->province,
      'postal_code' => $a->postal_code,
      'country' => $a->country,
    );

    // birthday
    if( !empty($person->birthday) ) {
      $uw->field_birthday = strtotime($person->birthday);
    }

    // phones
    foreach($person->phones AS $p) {
      if( $p->type == 'home' ) {
        $uw->field_home_phone = $p->phone;
      }
      if( $p->type == 'work' ) {
        $uw->field_work_phone = $p->phone;
      }
      if( $p->type == 'mobile' ) {
        $uw->field_mobile_phone = $p->phone;
      }
    }

    // member id - take the latest value, because it's the org ID - it should always match
    $uw->field_member_id = $membership->member_id;

    $org_site = module_exists('go_membership');

    // do these updates only if we're NOT on an org site. They are handled specially if
    // we do have an org site.
    if( !$org_site ) {
      // simple fields
      $uw->field_member_since = strtotime($membership->membership_start);
      $uw->field_dues_paid_until = strtotime($membership->dues_paid_until);

      // tags
      $uw->field_chapter_role = array();
      foreach($membership->tags AS $t) {

        // voice part
        if( $t->vocab == 'voice_part' ) {
          $tid = db_query("SELECT tid FROM taxonomy_term_data WHERE machine_name = :mname", 
                   array(':mname'=>$t->value))->fetchField();
          if( $tid ) {
            $uw->field_voice_part->set($tid);
          } else {
            watchdog('gs_mqsync', "Voice part machine name '{$t->value}' not found.");
          }
        }

        // chapter role (multi-value)
        if( $t->vocab == 'chapter_role' ) {
          $tid = db_query("SELECT tid FROM taxonomy_term_data WHERE machine_name = :mname", 
                   array(':mname'=>$t->value))->fetchField();
          if( $tid ) {
            $uw->field_chapter_role[] = $tid;
          } else {
            watchdog('gs_mqsync', "Voice part machine name '{$t->value}' not found.");
          }
        }
      }
    }

    $uw->save();

  } catch( Exception $e ) {
    $msg = t("Exception '@msg' at @backtrace on package: <pre>@package</pre>",
             array('@msg'=>$e->getMessage(), '@package'=>print_r($update_package,TRUE), '@backtrace'=>$e->getTraceAsString()));
    drupal_set_message($msg, 'error');
    watchdog('gs_mqsync', $msg);
  }


  if( $org_site ) {
    $origin_domain = $update_package['update_origin'];
    gs_mqsync_process_membership($user, $membership, $origin_domain);
  }

  return $created;
}

/**
 * If this is an org site, we need to find or create a membership record to connect
 * this user with a chapter record.
 */
function gs_mqsync_process_membership($user, $membership, $origin_domain) {

  $url = str_ireplace('http://', '', $origin_domain);

  // find a matching chapter record, or create one
  $chapter = _gs_mqsync_find_chapter( $url );

  if( !$chapter && variable_get('gs_mqsync_sync_create_chapters', TRUE) ) {
    $chapter = new StdClass();
    $chapter->type = 'go_chapter';
    $chapter->title = "Auto created for {$url}";
    node_object_prepare($chapter);
    $chapter->field_member_url[LANGUAGE_NONE][0]['url'] = $url;
    node_save($chapter);
  }

  // if there's no chapter found or created, there's nothing left to do
  if( !$chapter ) return;

  try {

    // find or create a membership record
    $query = new EntityFieldQuery();
    $query->entityCondition('entity_type', 'go_membership');
    $query->propertyCondition('user_uid', $user->uid);
    $query->propertyCondition('chapter_nid', $chapter->nid);
    $result = $query->execute();
    if( isset($result['go_membership']) ) {
      $list = entity_load('go_membership', array_keys($result['go_membership']));
      $org_membership = reset($list);
    } else {
      $org_membership = entity_create('go_membership', array('type'=>'go_membership'));
      $org_membership->user_uid = $user->uid;
      $org_membership->chapter_nid = $chapter->nid;
    }

    // set the fields on this membership and save
    $org_membership->label = "{$user->name} belongs to {$chapter->title}";
    $org_membership->login_name = $membership->login_name;
    $org_membership->login_pass = $membership->login_pass;
    $org_membership->member_id = $membership->member_id;
    $org_membership->membership_start = $membership->membership_start;
    $org_membership->membership_end = $membership->membership_end;
    $org_membership->dues_paid_until = $membership->dues_paid_until;

    $org_membership->save();

dpm($membership);
dpm($org_membership);
    // roles
dpm("deleting roles from {$org_membership->gomid}");
    db_query("DELETE from go_membership_role WHERE gomid = :gomid", array(':gomid'=>$org_membership->gomid));
    if( isset($membership->roles) ) {
      $query = db_insert('go_membership_role')->fields(array('gomid', 'role'));
      foreach($membership->roles AS $role_name) {
        $query->values(array('gomid'=>$org_membership->gomid, 'role'=>$role_name));
      }
      $query->execute();
    }

    // tags
dpm("deleting tags from {$org_membership->gomid}");
    db_query("DELETE from go_membership_tag WHERE gomid = :gomid", array(':gomid'=>$org_membership->gomid));
    $query = db_insert('go_membership_tag')->fields(array('gomid', 'vocab', 'value'));
    foreach($membership->tags AS $t) {
      $query->values(array(
        'gomid'=>$org_membership->gomid,
        'vocab'=>$t->vocab,
        'value'=>$t->value,
      ));
    }
    $query->execute();


    // special field handling on the user, taking into account the semantics of each field
    $uw = entity_metadata_wrapper('user', $user);

    // membership start - take the earliest value from all membership records for this person
    $earliest = db_query(
      "SELECT MIN(membership_start) FROM go_membership 
       WHERE user_uid = :user_uid AND NOT membership_start IS NULL",
      array(':user_uid'=>$user->uid)
    )->fetchField();
    $uw->field_member_since = strtotime($earliest);

    // membership end - set it when last membership is deleted (field currently does not exist)
    // TODO: do something with this

    // process tags

    // tags: voice part - just take the latest value. Doesn't matter much.
    //$uw->field_voice_part->set($tid);

    // tags: chapter role - set it to the union of all values
    //$uw->field_chapter_role = array();

    $uw->save();

  } catch( Exception $e ) {
    $msg = t("Exception '@msg' at @backtrace on package: <pre>@package</pre>",
             array('@msg'=>$e->getMessage(), '@package'=>print_r($update_package,TRUE), '@backtrace'=>$e->getTraceAsString()));
    drupal_set_message($msg, 'error');
    watchdog('gs_mqsync', $msg);
  }
}

/**
 * Process an incoming person delete record from Universe
 */
function gu_mqsync_process_person_delete($delete_package) {
  dpm($delete_package);
  return TRUE;
}
