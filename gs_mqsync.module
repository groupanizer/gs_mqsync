<?php

static $connection;

/**
 * Utility functions
 */

/**
 * semaphore to prevent loops while receiving a sync
 * - call with argument to set
 * - call with no argument to read
 */
function _gs_mqsync_receiving($set = null) {
  static $gs_mqsync_receiving_updates;
  if( !is_null($set) ) {
    $gs_mqsync_receiving_updates = $set;
  }
  return $gs_mqsync_receiving_updates;
}

/**
 * Substitute role IDs with machine names, and only send the named roles
 */
function _gs_mqsync_fix_roles($roles) {
  static $rolemap;
  if( !isset($rolemap) ) {
    $rolemap = db_query("SELECT rid, machine_name FROM role")->fetchAllKeyed();
  }
  $new_roles = array();
  foreach(array_keys($roles) AS $rid) {
    $machine_name = $rolemap[$rid];
    if( _g3core_role_category($machine_name) == 'named' ) {
      $new_roles[] = $machine_name;
    }
  }
  return $new_roles;
}

/**
 * Substitute term machine names for terms
 */
function _gs_mqsync_fix_taxonomy($tax) {
  // for single values
  if( isset($tax['tid']) ) {
    return db_query("SELECT machine_name FROM taxonomy_term_data WHERE tid = :tid",
      array(':tid'=>$tax['tid']))->fetchField();
  }
  // multi-value term reference fields
  if( isset($tax[0]['tid']) ) {
    $r = array();
    foreach($tax AS $t) {
      $r[] = _gs_mqsync_fix_taxonomy($t);
    }
    return $r;
  }
  // return whatever this was unchanged
  return $tax;
}

/** 
 * Convert domain name to queue name
 */
function _gs_mqsync_convert_domain_to_queue_name($domain) {
  // strip off any prefix
  $queue_name = str_replace('http://', '', $domain);
  // replace dots with underscore
  $queue_name = str_replace('.', '_', $queue_name);
  // trim just in case
  $queue_name = trim($queue_name);
  return $queue_name;
}


function gs_mqsync_menu() {

  // admin interface
  $items['admin/config/groupanizer/sync'] = array(
    'title' => 'Sync settings',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('gs_mqsync_settings_form'),
    'access arguments' => array('only user 1'),
    'file' => 'gs_mqsync.admin.inc',
  );

  // TEMPORARY
  $items['univrec'] = array(
    'title' => "Receive updated from universe",
    'page callback' => 'gs_mqsync_receive_updates',
    'access arguments' => array('bypass node access'),
    'type' => MENU_CALLBACK,
  );

  return $items;
}


/**
 * hook_cron
 * @purpose processes pending messages in the queue
 */
function gs_mqsync_cron() {
  gs_mqsync_process_queue();
}

/**
 * Main send method
 */
function gs_mqsync_send($queue, $operation, $package) {

  global $connection;

  if( !isset($connection) ) {
    $connection = RabbitMQConnection::get();
  }
  $channel = $connection->channel();
  $channel->queue_declare('universe_user', false, false, false, false);
  $msg = new  AMQPMessage(serialize(array(
    'operation' => $operation,
    'domain' => g3core_get_domain(),
    'data' => $package,
  )));
  $channel->basic_publish($msg, '', 'universe_user');
  
}

/**
 * define which fields we care about, for sending to universe or
 * for determining if a record has changed materially
 */
function gs_mqsync_person_fields() {
  static $fields;
  if( !isset($fields) ) {
    $fields = array(
      array( 'name'=>'uuid', 'type'=>'scalar'),
      array( 'name'=>'name', 'type'=>'scalar'),
      array( 'name'=>'pass', 'type'=>'scalar'),
      array( 'name'=>'mail', 'type'=>'scalar'),
      array( 'name'=>'roles', 'type'=>'array'),
      array( 'name'=>'field_first_name', 'type'=>'textfield'),
      array( 'name'=>'field_last_name', 'type'=>'textfield'),
      array( 'name'=>'field_member_id', 'type'=>'textfield'),
      array( 'name'=>'field_birthday', 'type'=>'datefield'),
      array( 'name'=>'field_address', 'type'=>'location'),
      array( 'name'=>'field_home_phone', 'type'=>'textfield'),
      array( 'name'=>'field_work_phone', 'type'=>'textfield'),
      array( 'name'=>'field_mobile_phone', 'type'=>'textfield'),
      array( 'name'=>'field_member_since', 'type'=>'datefield'),
      array( 'name'=>'field_dues_paid_until', 'type'=>'datefield'),
      array( 'name'=>'field_voice_part', 'type'=>'taxonomy'),
    );
    drupal_alter('mqsync_fields', $fields);
  }
  return $fields;
}

/**
 * clean up the person object for sending
 */
function gs_mqsync_send_person($queue, $operation, $account) {

  // just the fields we care about, and grab the best language
  $lang = isset($account->language) ? $account->language : LANGUAGE_NONE;
  $package = new StdClass();

  foreach( gs_mqsync_person_fields() AS $spec ) {

    $field_type = $spec['type'];
    $field = $spec['name'];

    switch( $field_type ) {
      case 'scalar':
        $package->$field = $account->$field;
        break;

      case 'roles':
        $package->$field = _gs_mqsync_fix_roles($account->$field);
        break;

      case 'textfield':
        if( isset($account->{$field}[$lang]) ) {
          $package->$field = $account->{$field}[$lang][0]['value'];
        } else if( isset($account->{$field}[LANGUAGE_NONE]) ) {
          $package->$field = $account->{$field}[LANGUAGE_NONE][0]['value'];
        }
        break;

      case 'datefield':
        if( isset($account->{$field}[$lang]) ) {
          $package->$field = $account->{$field}[$lang][0]['value'];
        } else if( isset($account->{$field}[LANGUAGE_NONE]) ) {
          $package->$field = $account->{$field}[LANGUAGE_NONE][0]['value'];
        }
        break;

      case 'location':
        $package->$field = $account->{$field}[LANGUAGE_NONE][0];
        // get rid of cruft
        unset($package->{$field}['location_settings']);
        break;

      case 'taxonomy':
        // pass the whole array
        if( isset($account->{$field}[$lang] ) ) {
          $package->$field = $account->{$field}[$lang];
        } else if( isset($account->{$field}[LANGUAGE_NONE] ) ) {
          $package->$field = $account->{$field}[LANGUAGE_NONE];
        }
        // substitute machine names
        $package->$field = _gs_mqsync_fix_taxonomy($package->$field);
        break;

      default:
        watchdog('gs_mqsync', "Unknown field type @type received - doing nothing.", array('@type'=>$field_type));
        break;
    }
  }

  gs_mqsync_send($queue, $operation, $package);
}

/**
 * hook_user_insert
 */
function gs_mqsync_user_insert(&$edit, $account, $category) {
  if( !variable_get('gs_mqsync_sync_send', TRUE) || _gs_mqsync_receiving() ) return;
  gs_mqsync_send_person('user', 'create', $account);
}

/**
 * hook_user_update
 */
function gs_mqsync_user_update(&$edit, $account, $category) {
  if( !variable_get('gs_mqsync_sync_send', TRUE) || _gs_mqsync_receiving() ) return;

// for now just send it all the time
gs_mqsync_send_person('user', 'update', $account);
return;

// later we'll skip sending if nothing changed
  foreach( gs_mqsync_person_fields() AS $field ) {
    if( !isset($account->$field) ) continue;
    if( $account->$field != $account->original->$field ) {
      gs_mqsync_send_person('user', 'update', $account);
      return;
    }
  }
}

/**
 * hook_user_delete
 */
function gs_mqsync_user_delete($account) {
  if( !variable_get('gs_mqsync_sync_send', TRUE) || _gs_mqsync_receiving() ) return;
  gs_mqsync_send('user', 'delete', $account->uuid);
}





/**
 * Manually grab any pending updates in the queue
 */
function gs_mqsync_receive_updates() {
  $result = gs_mqsync_process_queue();
  return 
    "Created {$result['created']} records<br>
    Updated {$result['updated']} records<br>
    Deleted {$result['deleted']} records<br>";

}

/**
 * Receive any pending messages and make the corresponding updates
 */

function gs_mqsync_process_queue() {

  if( !variable_get('gs_mqsync_sync_receive', TRUE) ) return;

  _gs_mqsync_receiving(TRUE);

  global $connection;

  if( !isset($connection) ) {
    $connection = RabbitMQConnection::get();
  }
  $channel = $connection->channel();

  $queue_name = _gs_mqsync_convert_domain_to_queue_name(g3core_get_domain());

  $channel->queue_declare($queue_name, false, false, false, false);

  $created_count = $updated_count = $deleted_count = 0;
  while( $msg = $channel->basic_get($queue_name, true) ) {
    $package = unserialize($msg->body);

    switch($package['operation']) {
      case 'person_update':
        $created = gs_mqsync_process_person_update($package['data']);
        if( $created ) {
          $created_count++;
        } else {
          $updated_count++;
        }
        break;

      case 'person_delete':
        $deleted = gu_mqsync_process_person_delete($package['data']);
        if( $deleted ) {
          $deleted_count++;
        }
        break;

      default:
        watchdog('gs_mqsync', "Unknown operation @op received - doing nothing.", array('@op'=>$data['operation']));
        break;
    }
  }

  // shut down the channel now that we're done with it
  $channel->close();
  $connection->close();
  unset($connection);
  
  return array(
    'created' => $created_count,
    'updated' => $updated_count,
    'deleted' => $deleted_count,
  );
}

/**
 * Process an incoming person record from Universe
 * @return TRUE if we created a new record, FALSE for an update
 */
function gs_mqsync_process_person_update($update_package) {

  try {

    $membership = $update_package['membership'];
    $person = $update_package['person'];

    // first let's see if we've already got a record for this person, by UUID
    $uuid = $person->uuid;
    $query = new EntityFieldQuery();
    $query->entityCondition('entity_type', 'user');
    $query->propertyCondition('uuid', $uuid);
    $result = $query->execute();

    if( isset($result['user']) ) {
      $ids = array_keys($result['user']);
      $list = entity_load('user', $ids);
      $user = reset($list);
      $created = FALSE;
    } else {
      $user = entity_create('user', array('type'=>'user'));
      $user->uuid = $uuid;
      $created = TRUE;
      // some fields that should only be set on creation
      $user->status = 1;
      $user->name = strtolower("{$person->first_name}.{$person->last_name}");
      foreach($person->emails AS $e) {
        if( $e->is_primary ) {
          $user->mail = $e->email;
        }
      }
    }

    // now update remaining fields and save the user object
    $uw = entity_metadata_wrapper('user', $user);
    $uw->field_first_name = $person->first_name;
    $uw->field_last_name = $person->last_name;

    // field_address
    $a = $person->field_address->und[0];
    $user->field_address[LANGUAGE_NONE][0] = array(
      'is_primary' => TRUE,
      'street' => $a->street,
      'city' => $a->city,
      'province' => $a->province,
      'postal_code' => $a->postal_code,
      'country' => $a->country,
    );

    // birthday
    if( !empty($person->birthday) ) {
      $uw->field_birthday = strtotime($person->birthday);
    }

    // phones
    foreach($person->phones AS $p) {
      if( $p->type == 'home' ) {
        $uw->field_home_phone = $p->phone;
      }
      if( $p->type == 'work' ) {
        $uw->field_work_phone = $p->phone;
      }
      if( $p->type == 'mobile' ) {
        $uw->field_mobile_phone = $p->phone;
      }
    }

    // from the membership record:
    // member id
    $uw->field_member_id = $membership->member_id;
    // membership start
    if( !empty($membership->membership_start) ) {
      $uw->field_member_since = strtotime($membership->membership_start);
    }
    // dues paid until
    if( !empty($membership->dues_paid_until) ) {
      $uw->field_dues_paid_until = strtotime($membership->dues_paid_until);
    }

    // membership end - not yet in the G3 data model
    //$uw->field_member_since = $membership->field_membership_start;

    // NB: DO NOT set the roles, because this would be a huge security gaffe.

    // tags

    // it's necessary to clear out the chapter role before we start, or we'll just collect
    // values forever
    $uw->field_chapter_role = array();

    foreach($membership->tags AS $t) {

      // voice part
      if( $t->vocab == 'voice_part' ) {
        $tid = db_query("SELECT tid FROM taxonomy_term_data WHERE machine_name = :mname", 
                 array(':mname'=>$t->value))->fetchField();
        if( $tid ) {
          $uw->field_voice_part->set($tid);
        } else {
          watchdog('gs_mqsync', "Voice part machine name '{$t->value}' not found.");
        }
      }

      // chapter role (multi-value)
      if( $t->vocab == 'chapter_role' ) {
        $tid = db_query("SELECT tid FROM taxonomy_term_data WHERE machine_name = :mname", 
                 array(':mname'=>$t->value))->fetchField();
        if( $tid ) {
          $uw->field_chapter_role[] =$tid;
        } else {
          watchdog('gs_mqsync', "Voice part machine name '{$t->value}' not found.");
        }

      }
    }

    // chapter

    $uw->save();

  } catch( Exception $e ) {
    $msg = t("Exception '@msg' at @backtrace on package: <pre>@package</pre>",
             array('@msg'=>$e->getMessage(), '@package'=>print_r($update_package,TRUE), '@backtrace'=>$e->getTraceAsString()));
    drupal_set_message($msg, 'error');
    watchdog('gs_mqsync', $msg);
  }

  return $created;
}

/**
 * Process an incoming person delete record from Universe
 */
function gu_mqsync_process_person_delete($delete_package) {
  dpm($delete_package);
  return TRUE;
}
